<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Missile Game Prototype</title>
    <style>
        body { margin: 0; display: flex; justify-content: center; align-items: center; height: 100vh; background-color: #333; overflow: hidden; }
        canvas { border: 1px solid #fff; background-color: #000; cursor: crosshair; outline: none; /* Remove focus outline if not desired */ }
        /* Basic message box styling */
        .message-box {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(255, 255, 255, 0.9);
            color: #333;
            padding: 10px 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            font-family: Arial, sans-serif;
            font-size: 16px;
            z-index: 1000;
            display: none; /* Hidden by default */
            text-align: center;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas" tabindex="0"></canvas>
    <div id="messageBox" class="message-box"></div>

    <script>
        // Get canvas and context
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // DOM Element for messages
        const messageBox = document.getElementById('messageBox');

        // Game constants
        const CANVAS_WIDTH = 800;
        const CANVAS_HEIGHT = 600;
        const BASE_COLOR = '#7f8c8d'; 
        const LAUNCHER_COLOR = '#95a5a6'; 
        const MISSILE_COLOR = '#e74c3c'; 
        const MISSILE_LAUNCHING_COLOR = '#f1c40f'; 
        const EXPLOSION_COLOR = '#e67e22'; 
        
        const BASE_WIDTH = 25; 
        const BASE_HEIGHT = 10; 
        const LAUNCHER_LENGTH = 12.5; 
        const LAUNCHER_THICKNESS = 2.5; 
        const MISSILE_RADIUS = 2; 

        const GRAVITY = 0.04; 
        const LAUNCH_ACCEL = 0.03; 
        const INITIAL_LAUNCH_SPEED = 0.1; 

        const EXPLOSION_DURATION_FRAMES = 40; 
        const MAX_EXPLOSION_RADIUS = 70; 
        const SHOCKWAVE_MAX_RADIUS_MULTIPLIER = 1.5; 
        const SHOCKWAVE_SPEED_DIVISOR = 1.5; 

        
        // Particle Constants
        const LAUNCH_PUFF_PARTICLE_COUNT = 30;
        const LAUNCH_PUFF_PARTICLE_LIFESPAN = 40; 
        const LAUNCH_PUFF_PARTICLE_SPEED = 1.5;
        const LAUNCH_PUFF_COLOR_START = [150, 150, 150]; 
        const LAUNCH_PUFF_COLOR_END = [80, 80, 80];   

        const TRAIL_PARTICLE_LIFESPAN = 600; 
        const TRAIL_PARTICLE_START_RADIUS = 1.25; 
        const TRAIL_PARTICLE_END_RADIUS = 0.25;   
        const TRAIL_SMOKE_COLOR_START = [130, 130, 130]; 
        const TRAIL_SMOKE_COLOR_END = [70, 70, 70];     
        const TRAIL_SMOKE_DRIFT = 0.15; 

        const ENEMY_DESTRUCTION_PARTICLE_COUNT = 25;
        const ENEMY_DESTRUCTION_PARTICLE_LIFESPAN = 50;
        const ENEMY_DESTRUCTION_PARTICLE_SPEED = 2;
        const ENEMY_DESTRUCTION_COLOR_PRIMARY = [255, 100, 0]; 
        const ENEMY_DESTRUCTION_COLOR_SECONDARY = [255, 200, 0]; 

        const GROUND_EXPLOSION_PARTICLE_COUNT = 40;
        const GROUND_EXPLOSION_LIFESPAN = 60;
        const GROUND_EXPLOSION_SPEED = 3;
        const MUSHROOM_STEM_PARTICLE_COUNT = 50;
        const MUSHROOM_STEM_LIFESPAN = 180; // MODIFIED: Increased stem lifespan
        const MUSHROOM_STEM_RISE_SPEED = -1.2; 
        const MUSHROOM_STEM_WIDTH = 20;
        const MUSHROOM_CAP_PARTICLE_COUNT = 80;
        const MUSHROOM_CAP_LIFESPAN = 250; // MODIFIED: Increased cap lifespan
        const MUSHROOM_CAP_EXPAND_SPEED = 0.8;
        const MUSHROOM_CAP_INITIAL_RADIUS = 5;
        const MUSHROOM_CAP_MAX_RADIUS = 80;


        // Enemy Constants
        const BOMBER_WIDTH = 30; 
        const BOMBER_HEIGHT = 10; 
        const BOMBER_SPEED = 0.75; 
        const BOMBER_SPAWN_INTERVAL = 300; 
        let bomberSpawnTimer = 0;
        const MAX_ONSCREEN_BOMBERS = 2; 
        const BOMBER_MAX_BOMBS_DROPPED = 2; 
        const BOMBER_DROP_INTERVAL_MIN = 120; 
        const BOMBER_DROP_INTERVAL_MAX = 300; 
        const BOMBER_SPAWN_MIN_Y_FACTOR = 0.1; 
        const BOMBER_SPAWN_MAX_Y_FACTOR = 0.5; 
        const BOMBER_CRASH_GRAVITY_FACTOR = 0.8; 

        const BOMB_RADIUS = 3; 
        const BOMB_LENGTH = BOMB_RADIUS * 2.5; 
        const BOMB_WIDTH = BOMB_RADIUS * 1.5;  
        const BOMB_FIN_SIZE = BOMB_RADIUS * 1.2;
        const BOMB_COLOR = '#555'; 
        const PARACHUTE_COLOR = '#bdc3c7'; 
        const PARACHUTE_DEPLOY_Y_FALL_DISTANCE_FACTOR = 0.1; 
        const PARACHUTE_FALL_SPEED = 0.6;

        const PARACHUTE_WIDTH = 12;
        const PARACHUTE_HEIGHT = 8;
        const TATTERED_PARACHUTE_WIDTH_FACTOR = 0.6;
        const TATTERED_PARACHUTE_HEIGHT_FACTOR = 0.5;
        const BOMB_GROUND_DETONATION_Y = CANVAS_HEIGHT - 2; // MODIFIED: Detonates 2px from bottom

        // Population and Game Over
        let population = 3000000;
        const INITIAL_POPULATION = 3000000;
        const MIN_POPULATION_LOSS = 27000;
        const MAX_POPULATION_LOSS = 35000;
        let gameOver = false;

        // City Building Constants
        const BUILDING_MAX_HEALTH = 100;
        const BUILDING_WIDTH_MIN = 30;
        const BUILDING_WIDTH_MAX = 60;
        const BUILDING_HEIGHT_MIN = 40;
        const BUILDING_HEIGHT_MAX = 120;
        const BUILDING_COLOR_HEALTHY = '#888'; // Light Grey
        const BUILDING_COLOR_DAMAGED_LOW = '#776666'; // Brownish Grey
        const BUILDING_COLOR_DAMAGED_HIGH = '#554444'; // Darker Brownish Grey
        const BUILDING_COLOR_DESTROYED = '#333';   // Very Dark Grey
        const BUILDING_BASE_GAP = BASE_WIDTH * 2.5; // Gap around player base


        // Canvas setup
        canvas.width = CANVAS_WIDTH;
        canvas.height = CANVAS_HEIGHT;

        // Mouse position
        let mousePos = { x: CANVAS_WIDTH / 2, y: CANVAS_HEIGHT / 2 };

        // Key states
        const keysPressed = {}; 

        // Game entity arrays
        let particles = [];
        let bombers = [];
        let bombs = [];
        let buildings = []; // MODIFIED: Array for buildings
        
        // Screen Flash
        let screenFlashTimer = 0;
        const SCREEN_FLASH_DURATION = 6; 
        const ENEMY_BOMB_FLASH_MULTIPLIER = 3; 

        // Missile States
        const MissileState = {
            IDLE: 'idle', 
            LAUNCH_PRESSED: 'launch_pressed',
            FLYING_FREE: 'flying_free',
            EXPLODING: 'exploding'
        };

        // --- Utility Functions ---
        showMessage = function(message, duration = 3000) { messageBox.textContent = message; messageBox.style.display = 'block'; setTimeout(() => { messageBox.style.display = 'none'; }, duration);};
        lerp = function(a, b, t) { return a + (b - a) * t; };
        distanceSquared = function(x1, y1, x2, y2) { const dx = x1 - x2; const dy = y1 - y2; return dx * dx + dy * dy; };
        checkCollisionCircleRect = function(circle, rect) { const cX = Math.max(rect.x, Math.min(circle.x, rect.x + rect.width)); const cY = Math.max(rect.y - rect.height, Math.min(circle.y, rect.y )); return distanceSquared(circle.x, circle.y, cX, cY) < (circle.radius * circle.radius); }; // Rect y is bottom for buildings


        // --- Particle System ---
        createParticle = function(x,y,vx,vy,size,color,life,type='generic',extras={}){ particles.push({x,y,vx,vy,initialSize:size,size,color,life,initialLife:life,type,...extras});};
        createLaunchPuff = function(x,y,launchAngle){for(let i=0;i<LAUNCH_PUFF_PARTICLE_COUNT;i++){const aO=(Math.random()-0.5)*Math.PI*0.8;const a=launchAngle+Math.PI+aO;const s=Math.random()*LAUNCH_PUFF_PARTICLE_SPEED+0.5;const vx=Math.cos(a)*s;const vy=Math.sin(a)*s;const sz=Math.random()*1.5+1;createParticle(x,y,vx,vy,sz,[...LAUNCH_PUFF_COLOR_START],LAUNCH_PUFF_PARTICLE_LIFESPAN,'launch_puff');}};
        createTrailSmokeParticle = function(x,y){const vx=(Math.random()-0.5)*TRAIL_SMOKE_DRIFT;const vy=(Math.random()-0.5)*TRAIL_SMOKE_DRIFT;createParticle(x,y,vx,vy,TRAIL_PARTICLE_START_RADIUS,[...TRAIL_SMOKE_COLOR_START],TRAIL_PARTICLE_LIFESPAN,'trail_smoke',{endRadius:TRAIL_PARTICLE_END_RADIUS});};
        createEnemyDestructionPuff = function(x,y){for(let i=0;i<ENEMY_DESTRUCTION_PARTICLE_COUNT;i++){const a=Math.random()*Math.PI*2;const s=Math.random()*ENEMY_DESTRUCTION_PARTICLE_SPEED+0.5;const vx=Math.cos(a)*s;const vy=Math.sin(a)*s;const sz=Math.random()*3+1.5;const iC=Math.random()<0.6?[...ENEMY_DESTRUCTION_COLOR_PRIMARY]:[...ENEMY_DESTRUCTION_COLOR_SECONDARY];createParticle(x,y,vx,vy,sz,iC,ENEMY_DESTRUCTION_PARTICLE_LIFESPAN,'enemy_explosion',{initialColor:iC});}};
        
        function createMushroomCloud(x, impactY) {
            for (let i = 0; i < GROUND_EXPLOSION_PARTICLE_COUNT; i++) {
                const angle = Math.random() * Math.PI * 2; const speed = Math.random() * GROUND_EXPLOSION_SPEED;
                const vx = Math.cos(angle) * speed; const vy = Math.sin(angle) * speed * 0.5 - Math.random()*1; 
                const size = Math.random() * 5 + 2; const color = Math.random() < 0.7 ? [139,69,19] : [100,100,100]; 
                createParticle(x, impactY, vx, vy, size, color, GROUND_EXPLOSION_LIFESPAN, 'ground_burst');
            }
            for (let i = 0; i < MUSHROOM_STEM_PARTICLE_COUNT; i++) {
                const randX = (Math.random() - 0.5) * MUSHROOM_STEM_WIDTH; const vx = (Math.random() - 0.5) * 0.2;
                const vy = MUSHROOM_STEM_RISE_SPEED * (0.8 + Math.random() * 0.4); const size = Math.random() * 8 + 4;
                const color = [60,60,60]; 
                setTimeout(() => { createParticle(x + randX, impactY, vx, vy, size, color, MUSHROOM_STEM_LIFESPAN, 'mushroom_stem', {expandRate: 0.05}); }, Math.random() * 500);
            }
             setTimeout(() => {
                const capCenterY = impactY + MUSHROOM_STEM_RISE_SPEED * MUSHROOM_STEM_LIFESPAN * 0.3; 
                for (let i = 0; i < MUSHROOM_CAP_PARTICLE_COUNT; i++) {
                    const angle = Math.random() * Math.PI * 2; const distFromCenter = Math.random() * MUSHROOM_CAP_INITIAL_RADIUS;
                    const startX = x + Math.cos(angle) * distFromCenter; const startY = capCenterY + Math.sin(angle) * distFromCenter * 0.5; 
                    const vx = Math.cos(angle) * MUSHROOM_CAP_EXPAND_SPEED * (0.5 + Math.random()*0.5);
                    const vy = Math.sin(angle) * MUSHROOM_CAP_EXPAND_SPEED * (0.5 + Math.random()*0.5) * 0.5 + MUSHROOM_STEM_RISE_SPEED*0.3; 
                    const size = Math.random() * 10 + 8; const color = Math.random() < 0.4 ? [255,140,0] : (Math.random() < 0.7 ? [200,200,200] : [100,100,100]); 
                    createParticle(startX, startY, vx, vy, size, color, MUSHROOM_CAP_LIFESPAN, 'mushroom_cap', {expandRate: 0.1, maxCapRadius: MUSHROOM_CAP_MAX_RADIUS * (0.5 + Math.random()*0.5)});
                }
            }, 800); // Increased delay for cap formation to allow stem to rise more

        }

        updateParticles = function(){for(let i=particles.length-1;i>=0;i--){const p=particles[i];p.x+=p.vx;p.y+=p.vy;p.life--;const lR=Math.max(0,p.life/p.initialLife);if(p.type==='launch_puff'){p.size=p.initialSize*lR;p.color=[lerp(LAUNCH_PUFF_COLOR_END[0],LAUNCH_PUFF_COLOR_START[0],lR),lerp(LAUNCH_PUFF_COLOR_END[1],LAUNCH_PUFF_COLOR_START[1],lR),lerp(LAUNCH_PUFF_COLOR_END[2],LAUNCH_PUFF_COLOR_START[2],lR)];}else if(p.type==='trail_smoke'){p.size=lerp(p.endRadius,p.initialSize,lR);p.color=[lerp(TRAIL_SMOKE_COLOR_END[0],TRAIL_SMOKE_COLOR_START[0],lR),lerp(TRAIL_SMOKE_COLOR_END[1],TRAIL_SMOKE_COLOR_START[1],lR),lerp(TRAIL_SMOKE_COLOR_END[2],TRAIL_SMOKE_COLOR_START[2],lR)];p.vx*=0.99;p.vy*=0.99;}else if(p.type==='enemy_explosion'){p.size=p.initialSize*lR*(1+(1-lR)*0.5);const c1=p.initialColor;const c2=[50,50,50];p.color=[lerp(c2[0],c1[0],lR),lerp(c2[1],c1[1],lR),lerp(c2[2],c1[2],lR)];p.vy+=GRAVITY*0.1;}else if(p.type==='ground_burst'){p.size=p.initialSize*lR;p.vy+=GRAVITY*0.2;}else if(p.type==='mushroom_stem'){p.size=Math.min(p.initialSize*(1+(1-lR)*p.expandRate*5), p.initialSize*2);p.vy*=0.98; p.vx*=0.98;}else if(p.type==='mushroom_cap'){p.size=Math.min(p.initialSize*(1+(1-lR)*p.expandRate*10),p.maxCapRadius*lR*1.5);p.vy*=0.95;p.vx*=0.95;}if(p.life<=0||p.size<=0.1){particles.splice(i,1);}}};
        drawParticles = function(){particles.forEach(p=>{const lR=Math.max(0,p.life/p.initialLife);let alpha;if(p.type==='launch_puff'){alpha=lR*0.7;}else if(p.type==='trail_smoke'){alpha=lR*0.4;}else if(p.type==='enemy_explosion' || p.type === 'ground_burst'){alpha=lR*0.9;}else if(p.type==='mushroom_stem'){alpha=lR*0.6;}else if(p.type==='mushroom_cap'){alpha=lR*0.7;}else{alpha=lR;}ctx.fillStyle=`rgba(${Math.round(p.color[0])},${Math.round(p.color[1])},${Math.round(p.color[2])},${alpha})`;if(p.size>0.1){ctx.beginPath();ctx.arc(p.x,p.y,p.size,0,Math.PI*2);ctx.fill();}});};


        // --- Base Object ---
        const base = { /* ... (same) ... */ };
        base.x=CANVAS_WIDTH/2;base.y=CANVAS_HEIGHT-BASE_HEIGHT/2;base.width=BASE_WIDTH;base.height=BASE_HEIGHT;base.launcherAngle=-Math.PI/2;base.getLauncherPivot=function(){return{x:this.x,y:this.y-this.height/2+LAUNCHER_THICKNESS/2};};base.getLauncherTip=function(){const p=this.getLauncherPivot();return{x:p.x+LAUNCHER_LENGTH*Math.cos(this.launcherAngle),y:p.y+LAUNCHER_LENGTH*Math.sin(this.launcherAngle)};};base.updateAim=function(targetPos){const p=this.getLauncherPivot();this.launcherAngle=Math.atan2(targetPos.y-p.y,targetPos.x-p.x);};base.draw=function(){ctx.fillStyle=BASE_COLOR;ctx.fillRect(this.x-this.width/2,this.y-this.height/2,this.width,this.height);ctx.beginPath();ctx.arc(this.x,this.y-this.height/2,this.width/3,Math.PI,2*Math.PI);ctx.fill();const p=this.getLauncherPivot(),t=this.getLauncherTip();ctx.strokeStyle=LAUNCHER_COLOR;ctx.lineWidth=LAUNCHER_THICKNESS;ctx.beginPath();ctx.moveTo(p.x,p.y);ctx.lineTo(t.x,t.y);ctx.stroke();ctx.lineWidth=1;};

        // --- Missile Object (Single Instance) ---
        const missile = { /* ... (same as previous version, with IDLE state) ... */ };
        missile.x=0;missile.y=0;missile.vx=0;missile.vy=0;missile.radius=MISSILE_RADIUS;missile.state=MissileState.IDLE;missile.angle=0;missile.explosionProgress=0;missile.currentExplosionRadius=0;missile.shockwaveRadius=0;missile.shockwaveMaxRadius=MAX_EXPLOSION_RADIUS*SHOCKWAVE_MAX_RADIUS_MULTIPLIER;missile.shockwaveExpansionRate=(MAX_EXPLOSION_RADIUS/EXPLOSION_DURATION_FRAMES)/SHOCKWAVE_SPEED_DIVISOR;
        missile.launch = function(launchAngle, startPos) {if (this.state === MissileState.IDLE) {this.state = MissileState.LAUNCH_PRESSED; this.angle = launchAngle; this.x = startPos.x; this.y = startPos.y;this.vx = Math.cos(this.angle) * INITIAL_LAUNCH_SPEED; this.vy = Math.sin(this.angle) * INITIAL_LAUNCH_SPEED;this.explosionProgress = 0; this.currentExplosionRadius = 0;this.shockwaveRadius = 0; createLaunchPuff(this.x, this.y, this.angle); showMessage("Missile Launched! Hold 'C' to accelerate.", 2000);}};
        missile.triggerExplosion = function() {if (this.state === MissileState.LAUNCH_PRESSED || this.state === MissileState.FLYING_FREE) {this.state = MissileState.EXPLODING; this.vx = 0; this.vy = 0;this.explosionProgress = 0; this.currentExplosionRadius = 0;this.shockwaveRadius = 0; screenFlashTimer = SCREEN_FLASH_DURATION; showMessage("KABOOM!", 1500);}};
        missile.reset = function() {this.state = MissileState.IDLE; const tip = base.getLauncherTip(); this.x = tip.x; this.y = tip.y; this.vx = 0; this.vy = 0;this.angle = base.launcherAngle; this.explosionProgress = 0; this.currentExplosionRadius = 0;this.shockwaveRadius = 0; };
        missile.update = function() {if (this.state === MissileState.LAUNCH_PRESSED) {if (!keysPressed['c']) {this.state = MissileState.FLYING_FREE;showMessage("Missile coasting.", 1000);} else {const thrustAx = Math.cos(this.angle) * LAUNCH_ACCEL; const thrustAy = Math.sin(this.angle) * LAUNCH_ACCEL;this.vx += thrustAx; this.vy += thrustAy;}createTrailSmokeParticle(this.x, this.y); } else if (this.state === MissileState.FLYING_FREE) {this.vy += GRAVITY;} else if (this.state === MissileState.EXPLODING) {this.explosionProgress++; if (this.explosionProgress < EXPLOSION_DURATION_FRAMES) {const fieryProgress = this.explosionProgress / EXPLOSION_DURATION_FRAMES;this.currentExplosionRadius = fieryProgress * MAX_EXPLOSION_RADIUS;} else {this.currentExplosionRadius = (this.explosionProgress === EXPLOSION_DURATION_FRAMES) ? MAX_EXPLOSION_RADIUS : 0;}if (this.shockwaveRadius < this.shockwaveMaxRadius) {this.shockwaveRadius += this.shockwaveExpansionRate;}this.shockwaveRadius = Math.min(this.shockwaveRadius, this.shockwaveMaxRadius);if (this.explosionProgress <= EXPLOSION_DURATION_FRAMES && this.currentExplosionRadius > 0) {for (let i = bombers.length - 1; i >= 0; i--) {const bomber = bombers[i];if (checkCollisionCircleRect({x: this.x, y: this.y, radius: this.currentExplosionRadius}, bomber)) {createEnemyDestructionPuff(bomber.x, bomber.y);bombers.splice(i, 1); continue; }}for (let i = bombs.length - 1; i >= 0; i--) {const bomb = bombs[i];if (distanceSquared(this.x, this.y, bomb.x, bomb.y) < (this.currentExplosionRadius + bomb.radius) * (this.currentExplosionRadius + bomb.radius)) {createEnemyDestructionPuff(bomb.x, bomb.y);bombs.splice(i, 1); continue; }} for(let i = buildings.length - 1; i >= 0; i--) { const bld = buildings[i]; if(checkCollisionCircleRect({x: this.x, y: this.y, radius: this.currentExplosionRadius}, {x: bld.x, y: bld.y, width: bld.width, height: bld.height})) { bld.health -= 50; if (bld.health < 0) bld.health = 0;}}}if (this.shockwaveRadius > 0) {for (let i = bombers.length - 1; i >= 0; i--) {const bomber = bombers[i]; if (!bomber.isCrashing && checkCollisionCircleRect({x: this.x, y: this.y, radius: this.shockwaveRadius}, bomber)) {bomber.isCrashing = true;bomber.vx = (Math.random() - 0.5) * BOMBER_SPEED * 0.3; bomber.vy = 0.1; bomber.rotation = 0;bomber.rotationSpeed = (Math.random() - 0.5) * 0.15 + 0.03 * (bomber.vx > 0 ? 1 : -1); }}for (let i = bombs.length - 1; i >= 0; i--) {const bomb = bombs[i];if (!bomb.isDisabledByShockwave && distanceSquared(this.x, this.y, bomb.x, bomb.y) < (this.shockwaveRadius + bomb.radius) * (this.shockwaveRadius + bomb.radius)) {bomb.isDisabledByShockwave = true; bomb.parachuteTattered = true; }} for(let i = buildings.length - 1; i >= 0; i--) { const bld = buildings[i]; if(checkCollisionCircleRect({x: this.x, y: this.y, radius: this.shockwaveRadius}, {x: bld.x, y: bld.y, width: bld.width, height: bld.height})) { bld.health -= 25; if (bld.health < 0) bld.health = 0;}}}if (this.explosionProgress >= EXPLOSION_DURATION_FRAMES && this.shockwaveRadius >= this.shockwaveMaxRadius) {this.reset(); }}if (this.state === MissileState.LAUNCH_PRESSED || this.state === MissileState.FLYING_FREE) {this.x += this.vx;this.y += this.vy;}if (this.state !== MissileState.EXPLODING && (this.x < -this.radius || this.x > CANVAS_WIDTH + this.radius || this.y > CANVAS_HEIGHT + this.radius || this.y < -CANVAS_HEIGHT)) { if (this.state !== MissileState.IDLE) { showMessage("Missile lost.", 1500); this.reset(); }}};
        missile.draw = function() { if (this.state === MissileState.EXPLODING && this.explosionProgress < EXPLOSION_DURATION_FRAMES) {const progress = this.explosionProgress / EXPLOSION_DURATION_FRAMES;const fieryRadius = progress * MAX_EXPLOSION_RADIUS; const alpha = 1 - progress; ctx.beginPath(); ctx.arc(this.x, this.y, fieryRadius, 0, Math.PI * 2);ctx.fillStyle = `rgba(230, 126, 34, ${alpha * 0.8})`; ctx.fill();ctx.beginPath(); ctx.arc(this.x, this.y, fieryRadius * 0.6, 0, Math.PI * 2);ctx.fillStyle = `rgba(241, 196, 15, ${alpha})`; ctx.fill();}if (this.state === MissileState.EXPLODING && this.shockwaveRadius > 0 && this.shockwaveRadius <= this.shockwaveMaxRadius) {const shockwaveAlpha = 0.4 * (1 - (this.shockwaveRadius / this.shockwaveMaxRadius)); ctx.strokeStyle = `rgba(220, 220, 255, ${shockwaveAlpha})`;ctx.lineWidth = 2 + 3 * (this.shockwaveRadius / this.shockwaveMaxRadius) ; if(this.shockwaveRadius > this.shockwaveMaxRadius / 2) { ctx.lineWidth = 2 + 3 * (1 - (this.shockwaveRadius / this.shockwaveMaxRadius));}ctx.beginPath();ctx.arc(this.x, this.y, this.shockwaveRadius, 0, Math.PI * 2);ctx.stroke();ctx.lineWidth = 1; }if (this.state === MissileState.LAUNCH_PRESSED || this.state === MissileState.FLYING_FREE) {ctx.save(); ctx.translate(this.x, this.y);let flightAngle = (this.vx === 0 && this.vy === 0) ? this.angle : Math.atan2(this.vy, this.vx);ctx.rotate(flightAngle);ctx.fillStyle = this.state === MissileState.LAUNCH_PRESSED ? MISSILE_LAUNCHING_COLOR : MISSILE_COLOR;ctx.beginPath(); ctx.ellipse(0, 0, this.radius * 1.5, this.radius * 0.8, 0, -Math.PI/2, Math.PI/2);ctx.lineTo(-this.radius * 0.5, 0); ctx.closePath(); ctx.fill();if (this.state === MissileState.LAUNCH_PRESSED) {ctx.fillStyle = EXPLOSION_COLOR; ctx.beginPath();ctx.moveTo(-this.radius * 1.5, 0);ctx.lineTo(-this.radius * 2.5 - (Math.random()*this.radius), this.radius * 0.5);ctx.lineTo(-this.radius * 2.5 - (Math.random()*this.radius), -this.radius * 0.5);ctx.closePath(); ctx.fill();}ctx.restore();} else if (this.state === MissileState.IDLE) { const tip = base.getLauncherTip();ctx.save(); ctx.translate(tip.x, tip.y);ctx.rotate(base.launcherAngle); ctx.fillStyle = MISSILE_COLOR;ctx.beginPath(); ctx.ellipse(0, 0, this.radius * 1.5, this.radius * 0.8, 0, -Math.PI/2, Math.PI/2);ctx.lineTo(-this.radius * 0.5, 0); ctx.closePath(); ctx.fill(); ctx.restore();}};


        // --- Bomber Object & Functions ---
        function spawnBomber() { /* ... (same) ... */ }
        function updateBombers() { /* ... (same) ... */ }
        function drawBombers() { /* ... (same) ... */ }
        spawnBomber = function(){const fL=Math.random()<0.5;const y=Math.random()*(CANVAS_HEIGHT*(BOMBER_SPAWN_MAX_Y_FACTOR-BOMBER_SPAWN_MIN_Y_FACTOR))+(CANVAS_HEIGHT*BOMBER_SPAWN_MIN_Y_FACTOR);const x=fL?-BOMBER_WIDTH/2:CANVAS_WIDTH+BOMBER_WIDTH/2;const vx=fL?BOMBER_SPEED:-BOMBER_SPEED;bombers.push({x,y,vx,vy:0,width:BOMBER_WIDTH,height:BOMBER_HEIGHT,dropTimer:Math.random()*(BOMBER_DROP_INTERVAL_MAX-BOMBER_DROP_INTERVAL_MIN)+BOMBER_DROP_INTERVAL_MIN,bombsDroppedCount:0,isCrashing:false,rotation:0,rotationSpeed:0,markedForRemoval:false,draw:function(){ctx.save();ctx.translate(this.x,this.y);if(this.isCrashing){ctx.rotate(this.rotation);ctx.fillStyle='#455A64';}else{ctx.fillStyle='#607D8B';}ctx.fillRect(-this.width/2,-this.height/2,this.width,this.height);const wW=this.width*0.4;const wH=this.height*1.8;ctx.fillRect(-wW/2,-wH/2,wW,wH);const tW=this.width*0.2;const tH=this.height*1.2;let tXO=this.isCrashing?this.width*0.3:(this.vx>0?-this.width*0.4:this.width*0.4);if(this.isCrashing&&this.vx<0)tXO=-this.width*0.3;ctx.fillRect(tXO-tW/2,-tH/2,tW,tH);ctx.restore();},update:function(){if(this.isCrashing){this.vy+=GRAVITY*BOMBER_CRASH_GRAVITY_FACTOR;this.y+=this.vy;this.x+=this.vx;this.vx*=0.99;this.rotation+=this.rotationSpeed;if(this.y>CANVAS_HEIGHT+this.height*2){this.markedForRemoval=true;}return;}this.x+=this.vx;this.dropTimer--;if(this.dropTimer<=0&&this.bombsDroppedCount<BOMBER_MAX_BOMBS_DROPPED){spawnBomb(this.x,this.y+this.height/2,this.y);this.bombsDroppedCount++;this.dropTimer=Math.random()*(BOMBER_DROP_INTERVAL_MAX-BOMBER_DROP_INTERVAL_MIN)+BOMBER_DROP_INTERVAL_MIN;}}});};
        updateBombers = function(){for(let i=bombers.length-1;i>=0;i--){const b=bombers[i];b.update();if(b.markedForRemoval||((!b.isCrashing)&&((b.vx>0&&b.x>CANVAS_WIDTH+b.width*2)||(b.vx<0&&b.x<-b.width*2)))){bombers.splice(i,1);}}bomberSpawnTimer--;if(bomberSpawnTimer<=0&&bombers.length<MAX_ONSCREEN_BOMBERS){spawnBomber();bomberSpawnTimer=BOMBER_SPAWN_INTERVAL;}else if(bomberSpawnTimer<=0&&bombers.length>=MAX_ONSCREEN_BOMBERS){bomberSpawnTimer=BOMBER_SPAWN_INTERVAL/3;}};
        drawBombers = function(){bombers.forEach(b=>b.draw());};


        // --- Bomb Object & Functions ---
        function spawnBomb(x, y, dropY) { 
            bombs.push({
                x, y,
                vx: 0, vy: 0, radius: BOMB_RADIUS, color: BOMB_COLOR,
                parachuteDeployed: false, initialDropY: dropY, 
                isDisabledByShockwave: false, 
                parachuteTattered: false, 
                hasDetonated: false, 
                draw: function() { /* ... (same as previous version) ... */ },
                update: function() { 
                    if (this.hasDetonated) return; // Already exploded, do nothing

                    // MODIFIED: Check for ground hit if disabled by shockwave
                    if (this.isDisabledByShockwave) {
                        this.vy += GRAVITY; // Fall normally
                        this.y += this.vy;
                        this.x += this.vx;
                        if (this.y >= CANVAS_HEIGHT - this.radius) { // Hit ground
                            this.hasDetonated = true; // Mark as "processed" to be removed, but no explosion
                            // createEnemyDestructionPuff(this.x, this.y); // Optional: small puff for dud
                        }
                        return; // Skip normal detonation logic
                    }
                    
                    // Normal bomb logic
                    if (!this.parachuteDeployed && (this.y - this.initialDropY) >= CANVAS_HEIGHT * PARACHUTE_DEPLOY_Y_FALL_DISTANCE_FACTOR) {
                        this.parachuteDeployed = true;
                        this.vy = PARACHUTE_FALL_SPEED; 
                    }

                    if (this.parachuteDeployed) {
                        this.vy = PARACHUTE_FALL_SPEED; 
                    } else {
                        this.vy += GRAVITY; 
                    }
                    this.y += this.vy;
                    this.x += this.vx; 

                    // MODIFIED: Ground detonation logic
                    if (this.y >= BOMB_GROUND_DETONATION_Y) { // Use new constant
                        this.hasDetonated = true; // Mark that it has detonated
                        createMushroomCloud(this.x, CANVAS_HEIGHT - 10); // Mushroom cloud starts near bottom
                        screenFlashTimer = SCREEN_FLASH_DURATION * ENEMY_BOMB_FLASH_MULTIPLIER;
                        const loss = Math.floor(Math.random() * (MAX_POPULATION_LOSS - MIN_POPULATION_LOSS + 1)) + MIN_POPULATION_LOSS;
                        population -= loss;
                        if (population < 0) population = 0;

                        // Damage buildings from bomb ground explosion
                        for(let i = buildings.length - 1; i >= 0; i--) {
                            const bld = buildings[i];
                            // Use MAX_EXPLOSION_RADIUS for bomb's ground impact for simplicity
                            if(checkCollisionCircleRect({x: this.x, y: CANVAS_HEIGHT, radius: MAX_EXPLOSION_RADIUS}, {x: bld.x, y: bld.y, width: bld.width, height: bld.height})) {
                                bld.health -= 75; // Bombs do significant damage to buildings
                                if (bld.health < 0) bld.health = 0;
                            }
                        }

                        if (population === 0 && !gameOver) {
                            gameOver = true;
                            showMessage("CITY DESTROYED - GAME OVER", 10000);
                        }
                    }
                }
            });
        }
        // (Copied spawnBomb draw method for brevity)
        spawnBomb = function(x,y,dropY){bombs.push({x,y,vx:0,vy:0,radius:BOMB_RADIUS,color:BOMB_COLOR,parachuteDeployed:false,initialDropY:dropY,isDisabledByShockwave:false,parachuteTattered:false,hasDetonated:false,draw:function(){ctx.save();ctx.translate(this.x,this.y);ctx.rotate(Math.PI/2);ctx.fillStyle=this.color;ctx.beginPath();ctx.ellipse(0,0,BOMB_LENGTH/2,BOMB_WIDTH/2,0,0,Math.PI*2);ctx.fill();ctx.beginPath();ctx.moveTo(-BOMB_LENGTH/2,0);ctx.lineTo(-BOMB_LENGTH/2-BOMB_FIN_SIZE,BOMB_FIN_SIZE/1.5);ctx.lineTo(-BOMB_LENGTH/2-BOMB_FIN_SIZE,-BOMB_FIN_SIZE/1.5);ctx.closePath();ctx.fill();ctx.restore();const pBY=this.y-BOMB_LENGTH/2-2;if(this.parachuteTattered){ctx.strokeStyle=PARACHUTE_COLOR;ctx.lineWidth=1;const tW=PARACHUTE_WIDTH*TATTERED_PARACHUTE_WIDTH_FACTOR;const tH=PARACHUTE_HEIGHT*TATTERED_PARACHUTE_HEIGHT_FACTOR;ctx.beginPath();ctx.moveTo(this.x-tW/2,pBY);ctx.quadraticCurveTo(this.x-tW/4,pBY-tH*1.2,this.x,pBY-tH);ctx.quadraticCurveTo(this.x+tW/4,pBY-tH*0.8,this.x+tW/2,pBY);ctx.stroke();ctx.beginPath();ctx.moveTo(this.x-tW/3,pBY);ctx.lineTo(this.x,this.y-BOMB_LENGTH/2+BOMB_RADIUS/2);ctx.moveTo(this.x+tW/4,pBY);ctx.lineTo(this.x,this.y-BOMB_LENGTH/2+BOMB_RADIUS/2);ctx.stroke();}else if(this.parachuteDeployed){ctx.strokeStyle=PARACHUTE_COLOR;ctx.lineWidth=1.5;ctx.beginPath();ctx.moveTo(this.x-PARACHUTE_WIDTH/2,pBY);ctx.quadraticCurveTo(this.x,pBY-PARACHUTE_HEIGHT,this.x+PARACHUTE_WIDTH/2,pBY);ctx.stroke();ctx.beginPath();ctx.moveTo(this.x-PARACHUTE_WIDTH/3,pBY);ctx.lineTo(this.x,this.y-BOMB_LENGTH/2+BOMB_RADIUS/2);ctx.moveTo(this.x+PARACHUTE_WIDTH/3,pBY);ctx.lineTo(this.x,this.y-BOMB_LENGTH/2+BOMB_RADIUS/2);ctx.stroke();}ctx.lineWidth=1;},update:function(){if(this.hasDetonated)return;if(this.isDisabledByShockwave){this.vy+=GRAVITY;this.y+=this.vy;this.x+=this.vx;if(this.y>=CANVAS_HEIGHT-this.radius){this.hasDetonated=true;}return;}if(!this.parachuteDeployed&&(this.y-this.initialDropY)>=CANVAS_HEIGHT*PARACHUTE_DEPLOY_Y_FALL_DISTANCE_FACTOR){this.parachuteDeployed=true;this.vy=PARACHUTE_FALL_SPEED;}if(this.parachuteDeployed){this.vy=PARACHUTE_FALL_SPEED;}else{this.vy+=GRAVITY;}this.y+=this.vy;this.x+=this.vx;if(this.y>=BOMB_GROUND_DETONATION_Y){this.hasDetonated=true;createMushroomCloud(this.x,CANVAS_HEIGHT-10);screenFlashTimer=SCREEN_FLASH_DURATION*ENEMY_BOMB_FLASH_MULTIPLIER;const loss=Math.floor(Math.random()*(MAX_POPULATION_LOSS-MIN_POPULATION_LOSS+1))+MIN_POPULATION_LOSS;population-=loss;if(population<0)population=0;for(let i=buildings.length-1;i>=0;i--){const bld=buildings[i];if(checkCollisionCircleRect({x:this.x,y:CANVAS_HEIGHT,radius:MAX_EXPLOSION_RADIUS},{x:bld.x,y:bld.y,width:bld.width,height:bld.height})){bld.health-=75;if(bld.health<0)bld.health=0;}}if(population===0&&!gameOver){gameOver=true;showMessage("CITY DESTROYED - GAME OVER",10000);}}}});};

        function updateBombs() { /* ... (same) ... */ }
        function drawBombs() { /* ... (same) ... */ }
        updateBombs = function(){for(let i=bombs.length-1;i>=0;i--){const b=bombs[i];b.update();if(b.hasDetonated||b.y>CANVAS_HEIGHT+b.radius*5){bombs.splice(i,1);}}};
        drawBombs = function(){bombs.forEach(b=>b.draw());};

        // --- City Building Functions ---
        function spawnBuildings() {
            buildings = []; // Clear existing buildings
            let currentX = 0;
            const buildingSpacing = 5; // Small gap between buildings

            while (currentX < CANVAS_WIDTH) {
                const buildingWidth = Math.random() * (BUILDING_WIDTH_MAX - BUILDING_WIDTH_MIN) + BUILDING_WIDTH_MIN;
                const buildingHeight = Math.random() * (BUILDING_HEIGHT_MIN - BUILDING_HEIGHT_MAX) + BUILDING_HEIGHT_MIN;

                // Check if this building overlaps with the base's exclusion zone
                const baseExclusionLeft = base.x - base.width / 2 - BUILDING_BASE_GAP;
                const baseExclusionRight = base.x + base.width / 2 + BUILDING_BASE_GAP;

                if (currentX + buildingWidth < baseExclusionLeft || currentX > baseExclusionRight) {
                    buildings.push({
                        x: currentX,
                        y: CANVAS_HEIGHT, // Bottom of the building is at the canvas bottom
                        width: buildingWidth,
                        height: buildingHeight,
                        health: BUILDING_MAX_HEALTH,
                        maxHealth: BUILDING_MAX_HEALTH,
                        color: BUILDING_COLOR_HEALTHY
                    });
                }
                currentX += buildingWidth + buildingSpacing;
            }
        }

        function updateBuildings() {
            // Buildings are static but their health/appearance can change
            buildings.forEach(bld => {
                if (bld.health <= 0) {
                    bld.color = BUILDING_COLOR_DESTROYED;
                    bld.height = BUILDING_HEIGHT_MIN / 3; // Rubble height
                } else if (bld.health < bld.maxHealth * 0.5) {
                    bld.color = BUILDING_COLOR_DAMAGED_HIGH;
                } else if (bld.health < bld.maxHealth) {
                    bld.color = BUILDING_COLOR_DAMAGED_LOW;
                } else {
                    bld.color = BUILDING_COLOR_HEALTHY;
                }
            });
        }

        function drawBuildings() {
            buildings.forEach(bld => {
                ctx.fillStyle = bld.color;
                // Buildings are drawn from their bottom-left corner (x, CANVAS_HEIGHT - height)
                ctx.fillRect(bld.x, CANVAS_HEIGHT - bld.height, bld.width, bld.height);
                // Optional: Add a simple border or detail
                if (bld.health > 0) {
                    ctx.strokeStyle = 'rgba(0,0,0,0.2)';
                    ctx.strokeRect(bld.x, CANVAS_HEIGHT - bld.height, bld.width, bld.height);
                }
            });
        }


        // --- Event Listeners (Single missile logic) ---
        canvas.addEventListener('mousemove',(e)=>{const r=canvas.getBoundingClientRect();mousePos.x=e.clientX-r.left;mousePos.y=e.clientY-r.top;});
        
        document.addEventListener('keydown',(e)=>{
            if (gameOver) return; 
            const k=e.key.toLowerCase();
            keysPressed[k]=true; 
            
            if(k==='c'){ 
                if (missile.state === MissileState.IDLE) { 
                    missile.launch(base.launcherAngle, base.getLauncherTip());
                }
            } else if(k===' '){
                e.preventDefault();
                missile.triggerExplosion(); 
            }
        });

        document.addEventListener('keyup',(e)=>{
            const k=e.key.toLowerCase();
            keysPressed[k]=false; 

            if(k==='c'){
                if (missile.state === MissileState.LAUNCH_PRESSED) {
                    missile.state = MissileState.FLYING_FREE;
                    showMessage("Missile coasting. Gravity active.", 2000);
                }
            }
        });
        
        // --- Game Loop ---
        function gameLoop() {
            ctx.fillStyle = 'rgba(0, 0, 10, 0.5)'; 
            ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

            if (!gameOver) {
                updateParticles(); 
                base.updateAim(mousePos);
                missile.update(); 
                updateBombers();
                updateBombs();
                updateBuildings(); // Update building states (e.g., color based on health)
            } else {
                updateParticles();
                updateBuildings(); // Still update buildings for visual consistency if game just ended
            }

            drawParticles(); 
            drawBuildings(); // Draw buildings behind other game elements (except base maybe)
            base.draw();
            missile.draw(); 
            drawBombers();
            drawBombs();
            
            if (screenFlashTimer > 0) {
                // Adjust flash intensity based on whether it's a player or enemy bomb flash
                const currentFlashDuration = screenFlashTimer > SCREEN_FLASH_DURATION ? SCREEN_FLASH_DURATION * ENEMY_BOMB_FLASH_MULTIPLIER : SCREEN_FLASH_DURATION;
                const flashProgress = screenFlashTimer / currentFlashDuration;
                const flashAlpha = 0.5 * flashProgress; // Fades out
                ctx.fillStyle = `rgba(255, 255, 255, ${flashAlpha})`;
                ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
                screenFlashTimer--;
            }
            
            // UI Text
            ctx.fillStyle = "rgba(255, 255, 255, 0.7)";
            ctx.font = "14px Arial";
            ctx.textAlign = "left";
            ctx.fillText("Aim: Mouse", 10, 20);
            ctx.fillText("Launch/Accelerate: Hold 'C'", 10, 40);
            ctx.fillText("Explode: Spacebar", 10, 60);
            ctx.fillText(`Missile State: ${missile.state}`, 10, 80); 
            ctx.fillText(`Particles: ${particles.length}`, 10, 100);
            ctx.fillText(`Bombers: ${bombers.length}`, 10, 120);
            ctx.fillText(`Bombs: ${bombs.length}`, 10, 140);

            ctx.textAlign = "right";
            ctx.fillText(`Population: ${population.toLocaleString()}`, CANVAS_WIDTH - 10, 20);
            ctx.textAlign = "left"; 

            if (gameOver) {
                ctx.fillStyle = "rgba(255, 0, 0, 0.8)";
                ctx.font = "60px Arial";
                ctx.textAlign = "center";
                ctx.fillText("GAME OVER", CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 - 20);
                ctx.font = "20px Arial";
                ctx.fillText(`Population: ${population.toLocaleString()}`, CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 + 30);
                ctx.fillText("Refresh to play again.", CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 + 60);

            }


            requestAnimationFrame(gameLoop);
        }

        // --- Initialization ---
        function init() {
            missile.reset(); 
            spawnBuildings(); // MODIFIED: Spawn buildings at start
            bomberSpawnTimer = BOMBER_SPAWN_INTERVAL / 2; 
            population = INITIAL_POPULATION; 
            gameOver = false; 
            showMessage("Game Ready! Defend the city!", 3000);
            canvas.focus(); 
            gameLoop();
        }

        window.onload = init;
    </script>
</body>
</html>
